{"version":3,"sources":["bundle.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\n/* util */\nlet hasProto = '__proto__' in {};\n\nfunction type(val) {\n    return Object.prototype.toString.call(val).slice(8, -1).toLowerCase();\n}\n\nfunction isUndef(v) {\n    return v === undefined || v === null;\n}\n\nfunction isObject(obj) {\n    return obj !== null && typeof obj  === 'object';\n}\n\nfunction isPlainObject(obj) {\n    return type(obj) === 'object';\n}\n\nfunction hasOwn(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nfunction def(obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n        value: val,\n        enumerable: !!enumerable,\n        writable: true,\n        configurable: true\n    });\n}\n\nfunction noop() {}\n\nfunction remove(arr, item) {\n    if (arr.length) {\n        let index = arr.indexOf(item);\n        if (index > -1) {\n            return arr.splice(index, 1);\n        }\n    }\n}\n\nfunction parsePath(path) {\n    let segments = path.split('.');\n    return function (obj) {\n        obj = obj.data;\n        for (let seg of segments) {\n            if (!obj) return;\n            obj = obj[seg];\n        }\n        return obj;\n    };\n}\n\n/* 依赖搜集器 */\nlet uid = 0;\nclass Dep {\n    constructor() {\n        this.id = uid++;\n        this.subs = [];\n    }\n    addSub(sub) {\n        this.subs.push(sub);\n    }\n    removeSub(sub) {\n        remove(this.subs, sub);\n    }\n    depend() {\n        if (Dep.target) {\n            Dep.target.addDep(this);\n        }\n    }\n    notify() {\n        this.subs.forEach(sub => sub.update());\n    }\n}\n\n/* 依赖搜集开关 */\nDep.target = null;\nlet targetStack = [];\nDep.pushTarget = function pushTarget(target) {\n    targetStack.push(target);\n    Dep.target = target;\n};\nDep.popTarget = function popTarget() {\n    targetStack.pop();\n    Dep.target = targetStack[targetStack.length - 1];\n};\n\n/* array */\nlet arrayProto = Array.prototype;\nlet arrayMethods = Object.create(arrayProto);\n\nlet methodsToPatch = [\n    'push',\n    'pop',\n    'shift',\n    'unshift',\n    'splice',\n    'sort',\n    'reverse'\n];\n\nmethodsToPatch.forEach(method => {\n    let original = arrayProto[method];\n    def(arrayMethods, method, function mutator(...args) {\n        let result = original.apply(this, args);\n        let ob = this.__ob__;\n        let inserted;\n        switch (method) {\n            case 'push':\n            case 'unshift':\n                inserted = args;\n                break;\n            case 'splice':\n                inserted = args.slice(2);\n                break;\n            default: break;\n        }\n        if (inserted) ob.observeArray(inserted);\n        ob.dep.notify();\n        return result;\n    });\n});\n\nfunction dependArray(value) {\n    value.forEach(val => {\n        val && val.__ob__ && val.__ob__.dep.depend();\n        if (Array.isArray(val)) {\n            dependArray(val);\n        }\n    });\n}\n\n/* 消息订阅器 */\nclass Observer {\n    constructor(value) {\n        this.value = value;\n        this.dep = new Dep();\n        def(value, '__ob__', this);\n        if (Array.isArray(value)) {\n            if (hasProto) {\n                value.__proto__ = arrayMethods;\n            } else {\n                Object.getOwnPropertyNames(arrayMethods).forEach(key => {\n                    def(value, key, arrayMethods[key]);\n                });\n            }\n            this.observeArray(value);\n        } else {\n            this.walk(value);\n        }\n    }\n    walk(value) {\n        Object.keys(value).forEach(key => {\n            // 忽略__xxx__类似的特殊属性\n            if (!/^__.*__$/gi.test(key)) {\n                defineReactive(value, key);\n            }\n        });\n    }\n    observeArray(value) {\n        value.forEach(val => Observer.observe(val));\n    }\n}\nObserver.observe = function observe(value) {\n    if (!isObject(value)) return;\n    let ob = null;\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n        ob = value.__ob__;\n    } else if (isPlainObject(value) || Array.isArray(value)) {\n        ob = new Observer(value);\n    }\n    return ob;\n};\n\n/* 定义响应式属性 */\nfunction defineReactive(obj, key, val) {\n    let dep = new Dep();\n    let property = Object.getOwnPropertyDescriptor(obj, key);\n    if (property && property.configurable === false) return;\n    if (isUndef(val)) {\n        val = obj[key];\n    }\n\n    let childOb = Observer.observe(val);\n    Object.defineProperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        get() {\n            if (Dep.target) {\n                dep.depend();\n                if (childOb) {\n                    childOb.dep.depend();\n                    if (Array.isArray(val)) {\n                        dependArray(val);\n                    }\n                }\n            }\n            return val;\n        },\n        set(newVal) {\n            if (newVal === val || (newVal !== newVal && val !== val)) return;\n            val = newVal;\n            childOb = Observer.observe(newVal);\n            dep.notify();\n        }\n    });\n}\n\n/* 观察者队列 */\n\nlet queue = [];\nlet index = 0;\nlet has = {};\nlet flushing = false;\nlet waiting = false;\n\nfunction flushWatcherQueue() {\n    flushing = true;\n    queue.sort((a, b) => a.id - b.id);\n    for (index = 0; index < queue.length; index++) {\n        let watcher = queue[index];\n        has[watcher.id] = null;\n        watcher.run();\n    }\n    index = queue.length = 0;\n    has = {};\n    flushing = waiting = false;\n}\n\nfunction queueWatcher(watcher) {\n    let id = watcher.id;\n    if (!has[id]) {\n        has[id] = true;\n        if (!flushing) {\n            queue.push(watcher);\n        } else {\n            let i = queue.length - 1;\n            while (i > index && queue[index].id > id) i--;\n            queue.splice(i + 1, 0, watcher);\n        }\n        if (!waiting) {\n            waiting = true;\n            setTimeout(flushWatcherQueue, 0);\n        }\n    }\n}\n\n/* 观察者 */\nlet uid$2 = 0;\nclass Watcher {\n    constructor(vm, key, expOrFn, cb) {\n        this.id = uid$2++;\n        this.vm = vm;\n        // computed key\n        this.key = key;\n        // watch callback\n        this.cb = cb || noop;\n        this.deps = [];\n        this.newDeps = [];\n        this.depIds = new Set();\n        this.newDepIds = new Set();\n        this.getter = noop;\n        // 小程序setData时会触发setter，避免在setter中改变依赖项目而进入死循环\n        this.isUpdating = false;\n\n        if (typeof expOrFn === 'function') {\n            // for computed\n            this.getter = expOrFn;\n        } else {\n            // for watch\n            this.getter = parsePath(expOrFn);\n        }\n\n        this.value = this.get();\n        this.updateView();\n    }\n    get() {\n        Dep.pushTarget(this);\n        let value = '';\n        try {\n            value = this.getter.call(this.vm, this.vm);\n        } catch (e) {\n\n        } finally {\n            Dep.popTarget();\n            this.cleanupDeps();\n        }\n        return value;\n    }\n    addDep(dep) {\n        let id = dep.id;\n        if (!this.newDepIds.has(id)) {\n            this.newDepIds.add(id);\n            this.newDeps.push(dep);\n            if (!this.depIds.has(id)) {\n                dep.addSub(this);\n            }\n        }\n    }\n    cleanupDeps() {\n        this.deps.forEach(dep => {\n            if (!this.newDepIds.has(dep.id)) {\n                dep.removeSub(this);\n            }\n        });\n        let tmp = this.depIds;\n        this.depIds = this.newDepIds;\n        this.newDepIds = tmp;\n        this.newDepIds.clear();\n        tmp = this.deps;\n        this.deps = this.newDeps;\n        this.newDeps = tmp;\n        this.newDeps.length = 0;\n    }\n    update() {\n        queueWatcher(this);\n    }\n    run() {\n        let value = this.getter.call(this.vm, this.vm);\n        if (value !== this.value || isObject(value)) {\n            let oldVal = this.value;\n            this.value = value;\n            this.updateView();\n            this.cb.call(this.vm, this.value, oldVal);\n        }\n    }\n    depend() {\n        this.deps.forEach(dep => dep.depend());\n    }\n    // 包装小程序更新视图的方法\n    updateView() {\n        if (!this.key || isUndef(this.value)) return;\n        this.isUpdating = true;\n        this.vm.setData({\n            [this.key]: this.value\n        });\n        this.isUpdating = false;\n    }\n}\n\n/* 各种初始化 */\nfunction initData(vm) {\n    Observer.observe(vm.data);\n}\n\nfunction initComputed(vm) {\n    let computed = vm.computed;\n    Object.keys(computed).forEach(key => {\n        let userDef = computed[key];\n        let getter = typeof userDef === 'function' ? userDef : userDef.get;\n        let watcher = new Watcher(vm, key, getter || noop, noop);\n        defineComputed(watcher, vm.data, key, userDef);\n    });\n}\n\nlet propertyConfig = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n};\nfunction defineComputed(watcher, target, key, userDef) {\n    if (typeof userDef === 'function') {\n        propertyConfig.get = createComputedGetter(watcher);\n        propertyConfig.set = noop;\n    } else {\n        propertyConfig.get = userDef.get ? createComputedGetter(watcher) : noop;\n        propertyConfig.set = createComputedSetter(watcher, userDef.set);\n    }\n    Object.defineProperty(target, key, propertyConfig);\n}\n\nfunction createComputedGetter(watcher) {\n    return function computedGetter() {\n        if (watcher) {\n            if (Dep.target) {\n                watcher.depend();\n            }\n            return watcher.value;\n        }\n    };\n}\n\nfunction createComputedSetter(watcher, userDefSet) {\n    return function computedSetter(val) {\n        if (watcher) {\n            if (!watcher.isUpdating) {\n                userDefSet && userDefSet.call(watcher.vm, val);\n            }\n        }\n    };\n}\n\nfunction initWatch(vm) {\n    let watch = vm.watch;\n    Object.keys(watch).forEach(key => new Watcher(vm, '', key, watch[key]));\n}\n\n/* 小程序中调用此接口进行注入 */\nfunction vueComputed(vm) {\n    if (!isPlainObject(vm)) {\n        throw new Error('请传入小程序页面或组件实例！');\n    }\n    vm.data && initData(vm);\n    vm.computed && initComputed(vm);\n    vm.watch && initWatch(vm);\n}\n\nmodule.exports = vueComputed;\n"]}